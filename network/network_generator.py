import os
import json
import random
import numpy as np
import networkx as nx
import plotly.io as pio   
import matplotlib.pyplot as plt
import plotly.graph_objects as go
pio.kaleido.scope.mathjax = None

""" controller modules """
from .. controllers import config_controller

# configuration variables
CONFIG = config_controller.ConfigController.get_config()

def generate_positions(number_nodes):
    positions =  np.random.rand(number_nodes, 2)
    pos = dict(zip(range(number_nodes),positions))
    return pos

def check_graph_conectivity(graph):
    #forces the graph to be a connected graph
    number_nodes = CONFIG['NETWORK']['BASE_STATIONS']
    graph_positions = generate_positions(number_nodes)
    graph = nx.random_geometric_graph(n=number_nodes, radius=0.25, pos=graph_positions)
   
   
    while not nx.is_connected(graph):
        print('Graph is not connected!')
        graph = nx.random_geometric_graph(n=number_nodes, radius=0.25)


def init_graph(rgg_graph, graph, graph_positions, custom_names):
    """ initialize GRAPH bases on RGG information """
    
    # gets the current node positions from RGG
    rgg_positions=nx.get_node_attributes(rgg_graph,'pos')
    
    #creates custom names for the nodes bases on the node id and its computing latency
    for node in rgg_graph.nodes():
        node_lower_latency_threshold = CONFIG['MEC_SERVERS']['LOWER_LATENCY_THRESHOLD']
        node_upper_latency_threshold = CONFIG['MEC_SERVERS']['UPPER_LATENCY_THRESHOLD']
        computing_latency = round(
            random.uniform(node_lower_latency_threshold, node_upper_latency_threshold), 2
        )
        node_name = str(node) + ' (' + str(computing_latency) + ')'
        custom_names[node] = node_name
    
    # adds nodes and their positions from RGG to GRAPH
    for node in rgg_graph.nodes():
        #modifies the original x and y coordinates generated by RGG
        random_x_pos = random.uniform(0, 1)
        random_y_pos = random.uniform(0, 1)
        x_pos = rgg_positions[node][0] #+ (rgg_positions[node][0] * random_x_pos)
        y_pos = rgg_positions[node][1] #+ (rgg_positions[node][1] * random_y_pos)
        
        graph.add_node(custom_names[node],pos=(x_pos,y_pos))
        node_position = np.array(rgg_positions[node], dtype=np.float32)
        graph_positions[custom_names[node]] = node_position
    
    # inserts edges from RGG into GRAPH
    for edge in rgg_graph.edges():
        src = edge[0]
        dst = edge[1]
        link_lower_latency_threshold = CONFIG['NETWORK']['LOWER_LATENCY_THRESHOLD']
        link_upper_latency_threshold = CONFIG['NETWORK']['UPPER_LATENCY_THRESHOLD']
        weight = round(
            random.uniform(link_lower_latency_threshold, link_upper_latency_threshold), 2
        ) # weight means the network latency of each link between two nodes  
        graph.add_edge(u_of_edge=custom_names[src], v_of_edge=custom_names[dst], weight=weight)
        

def draw_graph(graph, graph_positions):
    """ draws the GRAPH """    
    # provides different colors for each link according to their weight (latency)
    elarge = [(u, v) for (u, v, d) in graph.edges(data=True) if d["weight"] > 0.75]
    esmall = [(u, v) for (u, v, d) in graph.edges(data=True) if d["weight"] <= 0.75]
    
    # nodes
    nx.draw_networkx_nodes(graph, graph_positions, node_size=400)

    # edges
    nx.draw_networkx_edges(
        graph, graph_positions, 
        edgelist=elarge, 
        width=0.5, 
        style="dashed", 
        connectionstyle='arc3, rad = 0.2', 
        arrows=None, 
        arrowstyle='-'
    )
    nx.draw_networkx_edges(
        graph, graph_positions, 
        edgelist=esmall, 
        width=0.5, 
        alpha=0.5, 
        edge_color="b", 
        style="dashed", 
        connectionstyle='arc3, rad = 0.2', 
        arrows=None, 
        arrowstyle='-'
    )

    # node labels
    nx.draw_networkx_labels(graph, graph_positions, font_color='white', font_size=3, font_family="sans-serif", verticalalignment='top')
    
    # edge weight labels
    edge_labels = nx.get_edge_attributes(graph, "weight")
    nx.draw_networkx_edge_labels(graph, graph_positions, edge_labels, font_size=4)

    ax = plt.gca()
    ax.margins(0.08)
    plt.axis("off")
    plt.tight_layout()
    plt.savefig('network_topology.pdf', bbox_inches='tight', orientation='landscape', dpi=None)  
    #plt.show()
    

def save_to_json(rgg_graph, graph, graph_positions, custom_names, file_dir, file_name):
    # saves the graph into json file
    nodes_set = []
    edge_weights = nx.get_edge_attributes(graph, "weight")
    
    for node, adjacencies in enumerate(rgg_graph.adjacency()):
        node_edges = []
        node_edge_distances = [] 
        for edge, value in adjacencies[1].items():
            edge_pair = (custom_names[node], custom_names[edge])
            if edge_pair in edge_weights:
                node_edges.append(edge)
                node_edge_distances.append(edge_weights[edge_pair])
            
        node_name = custom_names[node]
        node_position = []
        p1 = json.dumps(float(graph_positions[node_name][0]))
        p2 = json.dumps(float(graph_positions[node_name][1]))
        node_position.append(float(p1))
        node_position.append(float(p2))
        
        #Python regex to return string between parentheses
        node_latency = node_name[node_name.find('(')+1:node_name.find(')')] 
      
        node = {'id': node, 'position': node_position, 'node_latency': float(node_latency) , 'edges': node_edges, 'edge_distances': node_edge_distances}
        nodes_set.append(node)

    json_text = json.dumps(nodes_set)
    f = open("{}{}".format(file_dir, file_name),"w+")
    f.write(json_text)
    f.close()    


def draw_plotly_graph(graph):
    edge_x = []
    edge_y = []
    for edge in graph.edges():
        x0, y0 = graph.nodes[edge[0]]['pos']
        x1, y1 = graph.nodes[edge[1]]['pos']
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)


    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=6, color='#888'),
        hoverinfo='none',
        mode='lines')

    node_x = []
    node_y = []
    for node in graph.nodes():
        x, y = graph.nodes[node]['pos']
        node_x.append(x)
        node_y.append(y)



    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            showscale=True,
            # colorscale options
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
            colorscale='YlGnBu',
            reversescale=True,
            color=[],
            size=50, # node size
            colorbar=dict(
                thickness=20,
                tickcolor='black',
                tickfont=dict(size=110, color='black', family='Times New Roman'),
                title=dict(text='Node Connections', font=dict(size=110, color='black', family='Times New Roman')),
                xanchor='left',
                titleside='right'
            ),
            line_width=5))

    node_adjacencies = []
    node_text = []
    for node, adjacencies in enumerate(graph.adjacency()):
        node_adjacencies.append(len(adjacencies[1]))
        node_text.append('# of connections: '+str(len(adjacencies[1])))

    #pprint(node_trace) # nodes location on the plot
    #pprint(node_adjacencies) # number of edges
    #pprint(node_text) # nodes adjacency text

    node_trace.marker.color = node_adjacencies
    node_trace.text = node_text



    fig = go.Figure(data=[edge_trace, node_trace],
                layout=go.Layout(
                    title='<br>',
                    titlefont_size=26,
                    showlegend=False,
                    hovermode='closest',
                    margin=dict(b=20,l=5,r=5,t=40),
                    paper_bgcolor='rgba(0,0,0,0)',
                    plot_bgcolor='rgba(0,0,0,0)',
                    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                    )
    #fig.show()
    fig.write_image("./plotly_network_topology.pdf", format="pdf", width=1980, height=1080)

def load_topology(rgg_graph, graph, graph_positions, custom_names, data_dir, file_name):
    data = {}
    with open("{}{}".format(data_dir, file_name)) as json_file:
        data = json.loads(json_file.read())
    
    #intializing custom_names
    for node in data:
        node_id = node['id']
        node_latency = node['node_latency']
        node_name = str(node_id) + ' (' + str(node_latency) + ')'
        custom_names[node_id] = node_name

    # adds nodes and their positions from RGG to GRAPH
    for node in data:
        node_id = node['id']
        node_position = node['position']
        x_pos = node_position[0]
        y_pos = node_position[1]
        graph.add_node(custom_names[node_id],pos=(x_pos, y_pos))
        node_position_aux = np.array(node_position, dtype=np.float32)
        graph_positions[custom_names[node_id]] = node_position_aux
    
    # inserts edges from json file into GRAPH
    for node in data:
        node_id = node['id']
        for edge in node['edges']:
            edge_distances = node['edge_distances']
            edge_index = node['edges'].index(edge)
            src = node_id
            dst = edge
            weight = edge_distances[edge_index]
            graph.add_edge(u_of_edge=custom_names[src], v_of_edge=custom_names[dst], weight=weight)
    
    draw_graph(graph, graph_positions)    
    #draw_plotly_graph(rgg_graph) #TODO: when loading the topology a new RGG graph should be created and specified into this function
    
def create_topology(rgg_graph, graph, graph_positions, custom_names, file_dir, file_name):
    print('\nCreating a new network topology...')
    check_graph_conectivity(rgg_graph)
    init_graph(rgg_graph, graph, graph_positions, custom_names)
    draw_graph(graph, graph_positions)
    save_to_json(rgg_graph, graph, graph_positions, custom_names, file_dir, file_name)
    draw_plotly_graph(rgg_graph)

if __name__ == "__main__":
    
    # variables
    GRAPH = nx.DiGraph()
    GRAPH_POSITIONS = {}
    CUSTOM_NAMES = {}
    
    #Random Geometric Graph uses as baseline for the final graph 
    RGG_GRAPH = nx.random_geometric_graph(n=28, radius=0.25)
    
    #file variables
    file_dir = './'
    file_name = 'network.json' 
    
    
    if os.path.exists('{}{}'.format(file_dir, file_name)):
        print(f'\n*** File {file_name} at {file_dir} already exists! ***')
        print('1- Create a new network topology')
        print('2- Load a network topology')
        option = input('\nEnter your choice: ')
        while option not in ['1', '2']:
            option = input('Enter your choice: ')
        
        if option == '1':
            create_topology(RGG_GRAPH, GRAPH, GRAPH_POSITIONS, CUSTOM_NAMES, file_dir, file_name)
        else:   
            print('\nLoading network topology...')
            load_topology(RGG_GRAPH, GRAPH, GRAPH_POSITIONS, CUSTOM_NAMES, file_dir, file_name)
    else:
        create_topology(RGG_GRAPH, GRAPH, GRAPH_POSITIONS, CUSTOM_NAMES, file_dir, file_name)
    
    '''
    TODO:
    1- TEST THE SCRIPT WITH CONTROLLER VARIABLES AND CHECK THE LINK LATENCY
    2- LOAD NET AND COMPUTING LATENCY FROM NETWORK.JSON FILE TO MECS AND BASE STATIONS
    3- CHECK THE DIJKSTRA ALGORITHM
    4- GET THE GENERATED FILE AND USE NODES' DISTANCES TO PLACE THE BASE STATIONS
    '''